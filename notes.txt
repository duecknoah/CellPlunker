a b	v c
1 1     0 1
0 0     0 0
0 1     1 0
1 0     1 0

value !(a and b) or !(!a and !b) or (!a and b) or (a and !b)
carry

after

value (xor gate)


How updates should work:
- There are different update types:
state update
cell update
	cell placed
	cell removed

If a cell is placed, it will update its neighbors via a cell update
If a cells state is changed, it will update its neighbors via a state update

	to do this, that cell will mark its neighbors in the stateUpdater by making an instance of CellUpdateInfo in the updateNext array. That way when the stateupdater is going through the updates, it just cycles through the array, identifies the update type, and runs the appropriate update for that Cell.
	This is done to ensure we are not running more code than we need to (ex. if there is a simple state update for a large cable, don't re-detect all neighboring non-cable cells, save that cpu intensive activity for when a new cell is placed or removed by it)


CableCells
	initialize
	    cUnit.initialize()
	cellUpdate
		cUnit.cellUpdate()
	stateUpdate
		cUnit.stateUpdate()
CableUnit
	cellUpdate()
		update state neighbors
		do everything the same as already in the update() event
	stateUpdate()
		do everything the same as the update() event, except do not update the stateneighbors

lags around 350

CableCell placing pseudo code (this code involves the process of solving connecting cableunit's conflicts):
{
when a cablecell is placed
	Put neighbors in an array called 'n'
	Put neighbors's cableUnits in an array called 'nCableUnit'
	loop through 'nCableUnit'
		for integer i=0 < 4
			for integer j=i+1 < 4
				if nCableUnit[i] == nCableUnit[j] // if two different neighbors share the same cableUnit, make one of the references null, as we don't want to recount the same cableunit
					nCableUnit[i] = null
					j = 3; // makes i go onto the next one, as there is no point in comparing j with i since it i is now null

	for i in 'nCableUnit'
		if (i == null)
			continue
		if we are not currently in a cableUnit
			join cableunit i
		else
			this.cableUnit.merge(i); // Combine this cableCell's cableUnit with i's
}

CableUnit merge function pseudo code:
{
	function merge(CableUnit other) {
		if (this == other)
			throw an Exception saying "You cannot merge two of the same CableUnits!"
		// Make all of the cables about to be added to have their cUnit reference refer to this cable unit
		for (i in other.cables)
			i.cUnit = this;
		this.neighbors.addAll(other.neighbors);
		this.cables.addAll(other.cables);
	}
}

CableCell deleting pseudo code (this is run before the cell is actually removed from the grid)
{
	this.cUnit.removeFromUnit(this);
}

CableUnit removing a CableCell from unit
function removeFromUnit(CableCell c) {

	Put neighbors in an array called 'n'
	Put CableCell neighbors in an array called 'cableNeighbors'
	Create an array of size 6 called 'connectedNeighbors'


	//////////////////////////// IDEA 1 ////////////////////////////////
	Make each cableNeighbor have a new CableUnit
		Get every connected CableCell and add it to the cables of this CableUnit
	
	for (CableCell i in cableNeighbors)
		cUnit = new CableUnit(new ArrayList<CableCell> )


	// Find out which neighbors have a cablepath connecting to every other neighbor, if they are connected, then make the two cableUnits the same. We do not merge as the CableCell's are all the same, this would create duplicates if we merged.
	loop through 'cableNeighbors'
		for integer i=0 < 4
			for integer j=i+1 < 4
				if (i == null || j == null)
					continue;
				CableUnit iC = cableNeighbors[i].getCableUnit();
				CableUnit jC = cableNeighbors[j].getCableUnit();
				// If 
				if (iC.cables.contains(cableNeighbors[j]))
					iC.merge(jC);
					for (CableCell k in jC.cables)
						k.cUnit = iC;



















	//////////////////////////// IDEA 2 ////////////////////////////////
	// Find out which neighbors have a cablepath connecting to every other neighbor
	loop through 'cableNeighbors'
		for integer i=0 < 4
			for integer j=i+1 < 4
				Put traced paths (ArrayLists) for each cableNeighbor in the connectedNeighbors array (to trace path, use A* algorithm, see https://www.youtube.com/watch?v=-L-WgKMFuhE)

	// Layout of connectedNeighbors boolean array, where it is true if those two neighbors
	// are connected via a CableCell path
	// R = RIGHT
	// T = TOP
	// L = LEFT
	// B = BOTTOM
	// {
	// [R-T],[R-L],[R-B],[T-L],[T-B],[L-B]
	// }

	for each connected neighbor in 'connectedNeighbors'	
		if they are not already part of the same CableUnit
			merge there two CableUnits
	for each 

	cables.remove(c);
}


Removing WirelessCable Cell (Cell Update)
Adding WirelessCable Cell (Cell Update)
Connecting Wireless Cable Cells (State Update)


Disconnecting Wireless Cable Cells (State Update)
	DisconnectFromOther() {
		Make the wirelessCableCell have a brand new CableUnit
		Trace connections and add connections to this cableUnit
	}